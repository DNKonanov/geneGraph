import argparse
import reverse
from collections import OrderedDict
import manage_db

parser = argparse.ArgumentParser()
parser.add_argument('-i', '--input_file', default='no', type=str, help='input_file, generated by Orthofinder')
parser.add_argument('-o', '--out_file', default='paths', type=str, help='output file prefix (default paths)')
args = parser.parse_args()


full_graph = OrderedDict()
length_table = OrderedDict()
coord_table = OrderedDict()


for line in open(args.input_file, 'r'):

	OG, string = line.split(': ')[0], line.split(': ')[1][:-1]


	stamms = string.split(' ')
	for stamm in stamms:
		name = stamm.split('|')[0]
		start_coord = int(stamm.split('|')[-2])
		end_coord = int(stamm.split('|')[-1])
		coord = int(stamm.split('|')[1])
		description = stamm.split('|')[2]
		contig_name = stamm.split('|')[3]

		if name not in full_graph:
			full_graph[name] = {contig_name:[(start_coord, end_coord, OG)]}
			coord_table[name] = {}
			length_table[name] = {}

		elif contig_name not in full_graph[name]:
			full_graph[name][contig_name] = [(start_coord, end_coord, OG)]

		else:
			full_graph[name][contig_name].append((start_coord, end_coord, OG))
		

		coord_table[name].update([(OG, (start_coord, end_coord, description))])
		length_table[name].update([(OG, end_coord - start_coord)])

graph = OrderedDict()
for name in full_graph:
	graph[name] = full_graph[name].copy()
	for contig in graph[name]:
		full_graph[name][contig].sort()
		graph[name][contig].sort()
		graph[name][contig] = [graph[name][contig][i][2] for i in range(len(graph[name][contig]))]




out = open(args.out_file + '.sif', 'a+')
out_freq = open(args.out_file + '_freq.sif', 'a+')


edges = []



G = set([])
for name in graph:

	S = set([])
	for contig in graph[name]:
		for gene in graph[name][contig]:
			if gene in S:
				G.add(gene)
				continue

			S.add(gene)


paralogues_table = {pg:[] for pg in G}
coord_list = {}
for name in graph:
	coord_list[name] = {}
	for contig in graph[name]:
		
		
		if len(graph[name][contig]) < 2:
			continue

		coord_list[name][contig] = []
		fixed_contig = []
		gene = 1
		graph[name][contig] = ['>'] + graph[name][contig] + ['>']
		while gene <= len(graph[name][contig]) - 2:
			context = False

			if (graph[name][contig][gene]) in paralogues_table:

				length = 1
				try:
					context_left = graph[name][contig][gene - 1]
					start_par_coord = full_graph[name][contig][gene - 2][1]

				except:
					context_left = '>'
					start_par_coord = full_graph[name][contig][gene-1][0]
				
				current_gene = graph[name][contig][gene]
				while graph[name][contig][gene + 1] == current_gene:
					gene += 1
					length += 1

				try:
					context_right = graph[name][contig][gene + 1]
					end_par_coord = full_graph[name][contig][gene][0]
				
				except:
					context_right = '>'
					end_par_coord = full_graph[name][contig][gene-1][1]
					

				for i in paralogues_table[graph[name][contig][gene]]:
					if context_left in i and context_right in i:

						new_name = 'P' + graph[name][contig][gene][1:] + '_' + str(i[2])
						fixed_contig.append(new_name)
						coord_list[name][contig].append((start_par_coord, end_par_coord))
						length_table[name].update([(new_name, length_table[name][graph[name][contig][gene]])])
						
						coord_table[name].update([(new_name, (start_par_coord, end_par_coord, coord_table[name][graph[name][contig][gene]][2]))])

						context = True
						break
				if context != True:
					par = len(paralogues_table[graph[name][contig][gene]])
					paralogues_table[graph[name][contig][gene]].append([context_left, context_right, par])

					
					new_name  = 'P' + graph[name][contig][gene][1:] + '_' + str(paralogues_table[graph[name][contig][gene]][-1][2])

					fixed_contig.append(new_name)
					coord_list[name][contig].append((start_par_coord, end_par_coord))

					length_table[name].update([(new_name, length_table[name][graph[name][contig][gene]])])
					coord_table[name].update([(new_name, (start_par_coord, end_par_coord, coord_table[name][graph[name][contig][gene]][2]))])
					

				gene += 1
				continue
			


			fixed_contig.append(graph[name][contig][gene])
			coord_list[name][contig].append((coord_table[name][graph[name][contig][gene]][0], coord_table[name][graph[name][contig][gene]][1]))
			gene += 1

		graph[name][contig] = fixed_contig

graph, reversed_chains = reverse.reverse(graph, length_table)

for name in graph:
	for contig in graph[name]:
		if contig in reversed_chains[name]:
			print(contig)
			coord_list[name][contig].reverse()


db = manage_db.create_connection(args.out_file + '.db')
sql_exec = """ CREATE TABLE IF NOT EXISTS stamms_table (
					id integer PRIMARY KEY,
					stamm text
				); """
manage_db.create_table(db, sql_exec)

sql_exec = """ CREATE TABLE IF NOT EXISTS contigs_table (
					id integer PRIMARY KEY,
					stamm_key text,
					contig text
				); """
manage_db.create_table(db, sql_exec)

sql_exec = """ CREATE TABLE IF NOT EXISTS og_table (
					id integer PRIMARY KEY,
					contig integer,
					og text,
					description text,
					start_coord integer,
					end_coord integer
				); """
manage_db.create_table(db, sql_exec)

sql_exec = """ CREATE TABLE IF NOT EXISTS og_complexity_table (
					contig integer,
					og text,
					win_var float,
					prob_win_var float,
					io float,
					prob_io float
				); """
manage_db.create_table(db, sql_exec)

sql_exec = """ CREATE TABLE IF NOT EXISTS freq_table (
					id integer PRIMARY KEY,
					edge_freq int,
					edge text,
					stamms_list text
				);"""

manage_db.create_table(db, sql_exec)



cursor = db.cursor()
stamm_key = 0
contig_key = 0
og_key = 0

for name in graph:
	print(name)
	print('---')
	cursor.execute('INSERT INTO stamms_table VALUES (' + str(stamm_key) + ',"' + name + '")')
	for contig in graph[name]:

		if len(graph[name][contig]) < 2:
			continue
		
		cursor.execute('INSERT INTO contigs_table VALUES (' + str(contig_key) + ',' + str(stamm_key) + ',"' + str(contig) + '")')
		
		for i in range(len(graph[name][contig])):
			
			gene = graph[name][contig][i]
			cursor.execute('INSERT INTO og_table VALUES('+ str(og_key) + ',' + str(contig_key) + ',"' + gene + '","' + coord_table[name][gene][2] + '",' + str(coord_list[name][contig][i][0]) + ',' + str(coord_list[name][contig][i][1]) + ')')

			og_key += 1
					

			if i == len(graph[name][contig]) - 1:
				continue
			line = graph[name][contig][i] + ' ' + graph[name][contig][i + 1] + ' ' + name + ' ' + contig + '\n'
			out.write(line)
		contig_key += 1	
	stamm_key += 1

freq = {}
for name in graph:
	for contig in graph[name]:
		for i in range(len(graph[name][contig]) - 1):
			if graph[name][contig][i] + ' ' + graph[name][contig][i + 1] not in freq:
				freq.update([(graph[name][contig][i] + ' ' + graph[name][contig][i + 1], [name])])

			else:
				freq[graph[name][contig][i] + ' ' + graph[name][contig][i + 1]].append(name)


freq_key = 0
for pair in freq:
	stamms_list = ''

	out_freq.write(pair + ' ' + str(len(freq[pair])) + ' ')
	for name in freq[pair]:
		out_freq.write(name)
		stamms_list += name
		if name is freq[pair][-1]:
			out_freq.write('\n')
			continue
		out_freq.write('|')
		stamms_list += ('\n')
	cursor.execute('INSERT INTO freq_table VALUES (' + str(freq_key) + ',' + str(len(freq[pair])) + ',"' + pair + '", ' + '"' + stamms_list + '")')
	freq_key += 1




db.commit()

db.close()
